NAME
    Parse::BBCode - Module to parse BBCode and render it as HTML or text

SYNOPSIS
    To parse a bbcode string, set up a parser with the default HTML
    defintions of Parse::BBCode::HTML:

        # render bbcode to HTML
        use Parse::BBCode;
        my $p = Parse::BBCode->new();
        my $code = 'some [b]b code[/b]';
        my $rendered = $p->render($code);

        # parse bbcode, manipulate tree and render
        use Parse::BBCode;
        my $p = Parse::BBCode->new();
        my $code = 'some [b]b code[/b]';
        my $tree = $p->parse($code);
        # do something with $tree
        my $rendered = $p->render_tree($tree);

    Or if you want to define your own tags:

        my $p = Parse::BBCode->new({
                tags => {
                    # load the default tags
                    Parse::BBCode::HTML->defaults,
                    
                # add/override tags
                    url => 'url:<a href="%{link}A">%{parse}s</a>',
                    i   => '<i>%{parse}s</i>',
                    b   => '<b>%{parse}s</b>',
                    noparse => '<pre>%{html}s</pre>',
                    code => sub {
                        my ($parser, $attr, $content, $attribute_fallback) = @_;
                        if ($attr eq 'perl') {
                            # use some syntax highlighter
                            $content = highlight_perl($content);
                        }
                        else {
                            $content = Parse::BBCode::escape_html($$content);
                        }
                        "<tt>$content</tt>"
                    },
                    test => 'this is klingon: %{klingon}s',
                },
                escapes => {
                    klingon => sub {
                        my ($parser, $tag, $text) = @_;
                        return translate_into_klingon($text);
                    },
                },
            }
        );
        my $code = 'some [b]b code[/b]';
        my $parsed = $p->render($code);

DESCRIPTION
    Note: This module is still experimental, the syntax is subject to
    change. I'm open for any suggestions on how to improve the syntax. See
    "TODO" for what might change.

    If you set up the Parse::BBCode object without arguments, the default
    tags are loaded, and any text outside or inside of parseable tags will
    go through a default subroutine which escapes HTML and replaces newlines
    with <br> tags. If you need to change this you can set the options
    'url_finder', 'text_processor' and 'linebreaks'.

  METHODS
    new Constructor. Takes a hash reference with options as an argument.

            my $parser = Parse::BBCode->new({
                tags => {
                    url => ...,
                    i   => ...,
                },
                escapes => {
                    link => ...,
                },
                close_open_tags   => 1, # default 0
                strict_attributes => 0, # default 0
                direct_attributes => 1, # default 1
                url_finder        => 1, # default 0
                smileys           => 0, # default 0
                linebreaks        => 1, # default 1
            );

        tags
            See "TAG DEFINITIONS"

        escapes
            See "ESCAPES"

        url_finder
            See "URL FINDER"

        smileys
            If you want to replace smileys with an icon:

                my $parser = Parse::BBCode->new({
                        smileys => {
                            base_url => '/your/url/to/icons/',
                            icons => { qw/ :-) smile.png :-( sad.png / },
                            # sprintf format:
                            # first argument url
                            # second argument original text smiley (HTML escaped)
                            format => '<img src="%s" alt="%s">',
                            # if you need the url and text in a different order
                            # see perldoc -f sprintf, e.g.
                            # format => '<img alt="%2$s" src="%1$s">',
                        },
                    });

            This subroutine will be applied during the url_finder (or first,
            if url_finder is 0), and the rest will get processed by the text
            procesor (default escaping html and replacing linebreaks).

            Smileys are only replaced if surrounded by whitespace or
            start/end of line/text.

                [b]bold<hr> :-)[/b] :-(

            In this example both smileys will be replaced. The first smiley
            is at the end of the text because the text inside [b][/b] is
            processed on its own.

            Open to any suggestions here.

        linebreaks
            The default text processor replaces linebreaks with <br>\n. If
            you don't want this, set 'linebreaks' to 0.

        text_processor
            If you need to add any customized text processing (like smiley
            parsing (although I will probably add builtin smiley support in
            one of the next versions)), you can pass a subroutine here. Note
            that this subroutine also needs to do HTML escaping itself!

            See "TEXT PROCESSORS"

        close_open_tags
            If set to true (1), it will close open tags at the end or before
            block tags.

        strict_attributes
            If set to true (1), tags with invalid attributes are left
            unparsed. If set to false (0), the attribute for this tags will
            be empty.

            An invalid attribute:

                [foo=bar far boo]...[/foo]

            I might add an option to define your own attribute validation.
            Contact me if you'd like to have this.

        direct_attributes
            Default: true

            Normal tag syntax is:

              [tag=val1 attr2=val2 ...]

            If set to 0, tag syntax is

              [tag attr2=val2 ...]

    render
        Input: The text to parse, optional hashref

        Returns: the rendered text

            my $rendered = $parser->render($bbcode);

        You can pass an optional hashref with information you need inside of
        your self-defined rendering subs. For example if you want to display
        code in a codebox with a link to download the code you need the id
        of the article (in a forum) and the number of the code tag.

            my $parsed = $parser->render($bbcode, { article_id => 23 });
            # in the rendering sub:
                my ($parser, $attr, $content, $attribute_fallback, $tag, $info) = @_;
                my $article_id = $parser->get_params->{article_id};
                my $code_id = $tag->get_num;
                # write downloadlink like
                # download.pl?article_id=$article_id;code_id=$code_id
                # in front of the displayed code

        See examples/code_download.pl for a complete example of how to set
        up the rendering and how to extract the code from the tree. If run
        as a CGI skript it will give you a dialogue to save the code into a
        file, including a reasonable default filename.

    parse
        Input: The text to parse.

        Returns: the parsed tree (a Parse::BBCode::Tag object)

            my $tree = $parser->parse($bbcode);

    render_tree
        Input: the parse tree

        Returns: The rendered text

            my $parsed = $parser->render_tree($tree);

        You can pass an optional hashref, for explanation see "render"

    forbid
            $parser->forbid(qw/ img url /);

        Disables the given tags.

    permit
            $parser->permit(qw/ img url /);

        Enables the given tags if they are in the tag definitions.

    escape_html
        Utility to substitute

            <>&"'

        with their HTML entities.

            my $escaped = Parse::BBCode::escape_html($text);

    error
        If the given bbcode is invalid (unbalanced or wrongly nested
        classes), currently Parse::BBCode::render() will either leave the
        invalid tags unparsed, or, if you set the option "close_open_tags",
        try to add closing tags. If this happened "error()" will return the
        invalid tag(s), otherwise false. To get the corrected bbcode (if you
        set "close_open_tags") you can get the tree and return the raw text
        from it:

            if ($parser->error) {
                my $tree = $parser->get_tree;
                my $corrected = $tree->raw_text;
            }

  TAG DEFINITIONS
    Here is an example of all the current definition possibilities:

        my $p = Parse::BBCode->new({
                tags => {
                    i   => '<i>%s</i>',
                    b   => '<b>%{parse}s</b>',
                    size => '<font size="%a">%{parse}s</font>',
                    url => 'url:<a href="%{link}A">%{parse}s</a>',
                    wikipedia => 'url:<a href="http://wikipedia.../?search=%{uri}A">%{parse}s</a>',
                    noparse => '<pre>%{html}s</pre>',
                    quote => 'block:<blockquote>%s</blockquote>',
                    code => {
                        code => sub {
                            my ($parser, $attr, $content, $attribute_fallback) = @_;
                            if ($attr eq 'perl') {
                                # use some syntax highlighter
                                $content = highlight_perl($$content);
                            }
                            else {
                                $content = Parse::BBCode::escape_html($$content);
                            }
                            "<tt>$content</tt>"
                        },
                        parse => 0,
                        class => 'block',
                    },
                    hr => {
                        class => 'block',
                        output => '<hr>',
                        single => 1,
                    },
                },
            }
        );

    The following list explains the above tag definitions:

    %s
            i => '<i>%s</i>'

            [i] italic <html> [/i]
            turns out as
            <i> italic &lt;html&gt; </i>

        So %s stands for the tag content. By default, it is parsed itself,
        so that you can nest tags.

    "%{parse}s"
            b   => '<b>%{parse}s</b>'

            [b] bold <html> [/b]
            turns out as
            <b> bold &lt;html&gt; </b>

        "%{parse}s" is the same as %s because 'parse' is the default.

    %a
            size => '<font size="%a">%{parse}s</font>'

            [size=7] some big text [/size]
            turns out as
            <font size="7"> some big text </font>

        So %a stands for the tag attribute. By default it will be HTML
        escaped.

    url tag, %A, "%{link}A"
            url => 'url:<a href="%{link}a">%{parse}s</a>'

        the first thing you can see is the "url:" at the beginning - this
        defines the url tag as a tag with the class 'url', and urls must not
        be nested. So this class definition is mainly there to prevent
        generating wrong HTML. if you nest url tags only the outer one will
        be parsed.

        another thing you can see is how to apply a special escape. The
        attribute defined with "%{link}a" is checked for a valid URL.
        "javascript:" will be filtered.

            [url=/foo.html]a link[/url]
            turns out as
            <a href="/foo.html">a link</a>

        Note that a tag like

            [url]http://some.link.example[/url]

        will turn out as

            <a href="">http://some.link.example</a>

        In the cases where the attribute should be the same as the content
        you should use %A instead of %a which takes the content as the
        attribute as a fallback. You probably need this in all url-like
        tags:

            url => 'url:<a href="%{link}A">%{parse}s</a>',

    "%{uri}A"
        You might want to define your own urls, e.g. for wikipedia
        references:

            wikipedia => 'url:<a href="http://wikipedia/?search=%{uri}A">%{parse}s</a>',

        "%{uri}A" will uri-encode the searched term:

            [wikipedia]Harold & Maude[/wikipedia]
            [wikipedia="Harold & Maude"]a movie[/wikipedia]
            turns out as
            <a href="http://wikipedia/?search=Harold+%26+Maude">Harold &amp; Maude</a>
            <a href="http://wikipedia/?search=Harold+%26+Maude">a movie</a>

    Don't parse tag content
        Sometimes you need to display verbatim bbcode. The simplest form
        would be a noparse tag:

            noparse => '<pre>%{html}s</pre>'

            [noparse] [some]unbalanced[/foo] [/noparse]

        With this definition the output would be

            <pre> [some]unbalanced[/foo] </pre>

        So inside a noparse tag you can write (almost) any invalid bbcode.
        The only exception is the noparse tag itself:

            [noparse] [some]unbalanced[/foo] [/noparse] [b]really bold[/b] [/noparse]

        Output:

            [some]unbalanced[/foo] <b>really bold</b> [/noparse]

        Because the noparse tag ends at the first closing tag, even if you
        have an additional opening noparse tag inside.

        The "%{html}s" defines that the content should be HTML escaped. If
        you don't want any escaping you can't say %s because the default is
        'parse'. In this case you have to write "%{noescape}".

    Block tags
            quote => 'block:<blockquote>%s</blockquote>',

        To force valid html you can add classes to tags. The default class
        is 'inline'. To declare it as a block add "'block:"" to the start of
        the string. Block tags inside of inline tags will either close the
        outer tag(s) or leave the outer tag(s) unparsed, depending on the
        option "close_open_tags".

    Define subroutine for tag
        All these definitions might not be enough if you want to define your
        own code, for example to add a syntax highlighter.

        Here's an example:

            code => {
                code => sub {
                    my ($parser, $attr, $content, $attribute_fallback, $tag, $info) = @_;
                    if ($attr eq 'perl') {
                        # use some syntax highlighter
                        $content = highlight_perl($$content);
                    }
                    else {
                        $content = Parse::BBCode::escape_html($$content);
                    }
                    "<tt>$content</tt>"
                },
                parse => 0,
                class => 'block',
            },

        So instead of a string you define a hash reference with a 'code' key
        and a sub reference. The other key is "parse" which is 0 by default.
        If it is 0 the content in the tag won't be parsed, just as in the
        noparse tag above. If it is set to 1 you will get the rendered
        content as an argument to the subroutine.

        The first argument to the subroutine is the Parse::BBCode object
        itself. The second argument is the attribute, the third is the
        already rendered tag content as a scalar reference and the fourth
        argument is the attribute fallback which is set to the content if
        the attribute is empty. The fourth argument is just for convenience.
        The fifth argument is the tag object (Parse::BBCode::Tag) itself, so
        if necessary you can get the original tag content by using:

            my $original = $tag->raw_text;

        The sixth argument is an info hash. It contains:

            my $info = {
                tags => $tags,
                stack => $stack,
                classes => $classes,
            };

        The variable $tags is a hashref which contains all tag names which
        are outside the current tag, with a count. This is convenient if you
        have to check if the current processed tag is inside a certain tag
        and you want to behave differently, like

            if ($info->{tags}->{special}) {
                # we are somewhere inside [special]...[/special]
            }

        The variable $stack contains an array ref with all outer tag names.
        So while processing the tag 'i' in

            [quote][quote][b]bold [i]italic[/i][/b][/quote][/quote]

        it contains [qw/ quote quote b i /]

        The variable $classes contains a hashref with all tag classes and
        their counts outside of the current processed tag. For example if
        you want to process URIs with URI::Find, and you are already in a
        tag with the class 'url' then you don't want to use URI::Find here.

            unless ($info->{classes}->{url}) {
                # not inside of a url class tag ([url], [wikipedia, etc.)
                # parse text for urls with URI::Find
            }

    Single-Tags
        Sometimes you might want single tags like for a horizontal line:

            hr => {
                class => 'block',
                output => '<hr>',
                single => 1,
            },

        The hr-Tag is a block tag (should not be inside inline tags), and it
        has no closing tag (option "single")

            [hr]
            Output:
            <hr>

ESCAPES
        my $p = Parse::BBCode->new({
            ...
            escapes => {
                link => sub {
                },
            },
        });

    You can define or override escapes. Default escapes are html, uri, link,
    email, htmlcolor, num. An escape functions as a validator and filter.
    For example, the 'link' escape looks if it got a valid URI (starting
    with "/" or "\w+://") and html-escapes it. It returns the empty string
    if the input is invalid.

    See "default_escapes" in Parse::BBCode::HTML for the detailed list of
    escapes.

URL FINDER
    Usually one wants to also create hyperlinks from any url found in the
    bbcode, not only in url tags. The following code will use URI::Find to
    search for all types of urls (unless inside of a url tag itself), create
    a link in the given format and html-escape the rest. If the url is
    longer than 50 chars, it will cut the link title and append three dots.
    If you set max_length to 0, the title won't be cut.

        my $p = Parse::BBCode->new({
                url_finder => {
                    max_length  => 50,
                    # sprintf format:
                    format      => '<a href="%s" rel="nofollow">%s</a>',
                },
                tags => ...
            });

    Note: If you use the special tag '' in the tag definitions you will
    overwrite the url finder and have to do that yourself.

    Alternative:

        my $p = Parse::BBCode->new({
                url_finder => 1,
                ...

    This will use the default like shown above (max length 50 chars).

    Default is 0.

TEXT PROCESSORS
    If you set url_finder and linebreaks to 1, the default text processor
    will work like this:

        my $post_processor = \&sub_for_escaping_HTML;
        $text = code_to_replace_urls($text, $post_processor);
        $text =~ s/\r?\n|\r/<br>\n/g;
        return $text;

    It will be applied to text outside of bbcode and inside of parseable
    bbcode tags (and not to code tags or other tags with unparsed content).

    If you need an additional post processor this usually cannot be done
    after the HTML escaping and url finding. So if you write a text
    processor it must do the HTML escaping itself. For example if you want
    to replace smileys with image tags you cannot simply do:

        $text =~ s/ :-\) /<img src=...>/g;

    because then the image tag would be HTML escaped after that. On the
    other hand it's usually not possible to do something like that *after*
    the HTML escaping since that might introduce text sequences that look
    like a smiley (or whatever you want to replace).

    So a simple example for a customized text processor would be:

        ...
        url_finder     => 1,
        linebreaks     => 1,
        text_processor => sub {
            # for $info hash description see render() method
            my ($text, $info) = @_;
            my $out = '';
            while ($text =~ s/(.*)( |^)(:\))(?= |$)//mgs) {
                # match a smiley and anything before
                my ($pre, $sp, $smiley) = ($1, $2, $3);
                # escape text and add smiley image tag
                $out .= Parse::BBCode::escape_html($pre) . $sp . '<img src=...>';
            }
            # leftover text
            $out .= Parse::BBCode::escape_html($text);
            return $out;
        },

    This will result in: Replacing urls, applying your text_processor to the
    rest of the text and after that replace linebreaks with <br> tags.

    If you want to completely define the plain text processor yourself
    (ignoring the 'linebreak', 'url_finder' and 'text_processor' options)
    you define the special tag with the empty string:

        my $p = Parse::BBCode->new({
            tags => {
                '' => sub {
                    my ($parser, $attr, $content, $info) = @_;
                    return frobnicate($content);
                    # remember to escape HTML!
                },
                ...

WHY ANOTHER BBCODE PARSER
    I wrote this module because HTML::BBCode is not extendable (or I didn't
    see how) and BBCode::Parser seemed good at the first glance but has some
    issues, for example it says that the following bbode

        [code] foo [b] [/code]

    is invalid, while I think you should be able to write unbalanced code in
    code tags. Also BBCode::Parser dies if you have invalid code or
    not-permitted tags, but in a forum you'd rather show a partly parsed
    text then an error message.

    What I also wanted is an easy syntax to define own tags, ideally - for
    simple tags - as plain text, so you can put it in a configuration file.
    This allows forum admins to add tags easily. Some forums might want a
    tag for linking to perlmonks.org, other forums need other tags.

    Another goal was to always output a result and don't die. I might add an
    option which lets the parser die with unbalanced code.

TODO
    BBCode to Textile|Markdown
        There is a Parse::BBCode::Markdown module which is only roughly
        tested.

    API The main syntax is likely to stay, only the API for callbacks might
        change. At the moment it is not possible to add callbacks to the
        parsing process, only for the rendering phase. It is also not
        possible to declare your own attribute syntax, for example

            [quote=nickname date]

        Attributes always have to look like:

            [tag=main_attribute other=foo]...
            [tag="main_attribute" other="foo"]...

        I would like to add support for different syntax, because it might
        happen that one has old bbcode lying around (maybe taken over from a
        different forum software) and cannot manually replace all the
        invalid bbcode.

    Short bbcode like syntax for urls
        Since I need this myself in my board software and currently do the
        replacing in the text processor I would like to add tags like this:

            [cpan://This::Module|title]

REQUIREMENTS
    perl >= 5.6.1, Class::Accessor::Fast, URI::Escape

SEE ALSO
    BBCode::Parser - a parser which supplies the parsed tree if necessary.
    Too strict though for using in forums where people write unbalanced
    bbcode

    HTML::BBCode - simple processor, no parse tree, good enough for
    processing usual bbcode with the most common tags

    HTML::BBReverse - really simple proccessor, just replaces start and end
    tags independently by their HTML aequivalents, so not very useful in
    many cases

    See "examples/compare.html" for a feature comparison of the modules and
    feel free to report mistakes.

    See "examples/bench.pl" for a benchmark of the modules.

BUGS
    Please report bugs at
    http://rt.cpan.org/NoAuth/Bugs.html?Dist=Parse-BBCode

AUTHOR
    Tina Mueller

CREDITS
    Thanks to Moritz Lenz for his suggestions about the implementation and
    the test cases.

    Viacheslav Tikhanovskii

    Sascha Kiefer

COPYRIGHT AND LICENSE
    Copyright (C) 2011 by Tina Mueller

    This library is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself, either Perl version 5.6.1 or, at
    your option, any later version of Perl 5 you may have available.

