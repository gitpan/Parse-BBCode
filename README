NAME
    Parse::BBCode - Module to turn BBCode into HTML or plain text

SYNOPSIS
    To parse a bbcode string, set up a parser with the default HTML
    defintions of Parse::BBCode::HTML:

        use Parse::BBCode;
        my $p = Parse::BBCode->new();
        my $code = 'some [b]b code[/b]';
        my $parsed = $p->render($code);

    Or if you want to define your own tags:

        my $p = Parse::BBCode->new({
                tags => {
                    # load the default tags
                    Parse::BBCode::HTML->defaults,
                    
                # add/override tags
                    url => 'url:<a href="%{link}A">%{parse}s</a>',
                    i   => '<i>%{parse}s</i>',
                    b   => '<b>%{parse}s</b>',
                    noparse => '<pre>%{html}s</pre>',
                    code => sub {
                        my ($parser, $attr, $content, $attribute_fallback) = @_;
                        if ($attr eq 'perl') {
                            # use some syntax highlighter
                            $content = highlight_perl($content);
                        }
                        else {
                            $content = Parse::BBCode::escape_html($$content);
                        }
                        "<tt>$content</tt>"
                    },
                    test => 'this is klingon: %{klingon}s',
                },
                escapes => {
                    klingon => sub {
                        my ($parser, $tag, $text) = @_;
                        return translate_into_klingon($text);
                    },
                },
            }
        );
        my $code = 'some [b]b code[/b]';
        my $parsed = $p->render($code);

DESCRIPTION
    Note: This module is still experimental, the syntax is subject to
    change. I'm open for any suggestions on how to improve the syntax. See
    "TODO" for what might change.

    I wrote this module because HTML::BBCode is not extendable (or I didn't
    see how) and BBCode::Parser seemed good at the first glance but has some
    issues, for example it says that the following bbode

        [code] foo [b] [/code]

    is invalid, while I think you should be able to write unbalanced code in
    code tags. Also BBCode::Parser dies if you have invalid code or
    not-permitted tags, but in a forum you'd rather show a partly parsed
    text then an error message.

    What I also wanted is an easy syntax to define own tags, ideally - for
    simple tags - as plain text, so you can put it in a configuration file.
    This allows forum admins to add tags easily. Some forums might want a
    tag for linking to perlmonks.org, other forums need other tags.

    Another goal was to always output a result and don't die. I might add an
    option which lets the parser die with unbalanced code.

  METHODS
    new Constructor. Takes a hash reference with options as an argument.

            my $parser = Parse::BBCode->new({
                tags => {
                    url => ...,
                    i   => ...,
                },
                escapes => {
                    link => ...,
                },
                close_open_tags   => 1, # default 0
                strict_attributes => 0, # default 0
            );

        tags
            See "TAG DEFINITIONS"

        escapes
            See "ESCAPES"

        close_open_tags
            If set to true (1), it will close open tags at the end or before
            block tags.

        strict_attributes
            If set to true (1), tags with invalid attributes are left
            unparsed. If set to false (0), the attribute for this tags will
            be empty.

            An invalid attribute:

                [foo=bar far boo]...[/foo]

            I might add an option to define your own attribute validation.
            Contact me if you'd like to have this.

        direct_attributes
            Default: true

            Normal tag syntax is:

              [tag=val1 attr2=val2 ...]

            If set to 0, tag syntax is

              [tag attr2=val2 ...]

    render
        Input: The text to parse, optional hashref

        Returns: the rendered text

            my $rendered = $parser->render($bbcode);

        You can pass an optional hashref with information you need inside of
        your self-defined rendering subs. For example if you want to display
        code in a codebox with a link to download the code you need the id
        of the article (in a forum) and the number of the code tag.

            my $parsed = $parser->render($bbcode, { article_id => 23 });
            # in the rendering sub:
                my ($parser, $attr, $content, $attribute_fallback, $tag, $info) = @_;
                my $article_id = $parser->get_params->{article_id};
                my $code_id = $tag->get_num;
                # write downloadlink like
                # download.pl?article_id=$article_id;code_id=$code_id
                # in front of the displayed code

        See examples/code_download.pl

    parse
        Input: The text to parse.

        Returns: the parsed tree (a Parse::BBCode::Tag object)

            my $tree = $parser->parse($bbcode);

    render_tree
        Input: the parse tree

        Returns: The rendered text

            my $parsed = $parser->render_tree($tree);

        You can pass an optional hashref, for explanation see "parse"

    forbid
            $parser->forbid(qw/ img url /);

        Disables the given tags.

    permit
            $parser->permit(qw/ img url /);

        Enables the given tags if they are in the tag definitions.

    escape_html
        Utility to substitute

            <>&"'

        with their HTML entities.

            my $escaped = Parse::BBCode::escape_html($text);

    error
        If the given bbcode is invalid (unbalanced or wrongly nested
        classes), currently Parse::BBCode::render() will either leave the
        invalid tags unparsed, or, if you set the option "close_open_tags",
        try to add closing tags. If this happened "error()" will return the
        invalid tag(s), otherwise false. To get the corrected bbcode (if you
        set "close_open_tags") you can get the tree and return the raw text
        from it:

            if ($parser->error) {
                my $tree = $parser->get_tree;
                my $corrected = $tree->raw_text;
            }

  TAG DEFINITIONS
    Here is an example of all the current definition possibilities:

        my $p = Parse::BBCode->new({
                tags => {
                    '' => sub {
                        my ($parser, $attr, $content, $info) = @_;
                        # for explanation of $info see below
                        # at "Define subroutine for tag"
                        my $e = Parse::BBCode::escape_html($content);
                        $e =~ s/\r?\n|\r/<br>\n/g;
                        $e
                    },
                    i   => '<i>%s</i>',
                    b   => '<b>%{parse}s</b>',
                    size => '<font size="%a">%{parse}s</font>',
                    url => 'url:<a href="%{link}A">%{parse}s</a>',
                    wikipedia => 'url:<a href="http://wikipedia.../?search=%{uri}A">%{parse}s</a>',
                    noparse => '<pre>%{html}s</pre>',
                    quote => 'block:<blockquote>%s</blockquote>',
                    code => {
                        code => sub {
                            my ($parser, $attr, $content, $attribute_fallback) = @_;
                            if ($attr eq 'perl') {
                                # use some syntax highlighter
                                $content = highlight_perl($$content);
                            }
                            else {
                                $content = Parse::BBCode::escape_html($$content);
                            }
                            "<tt>$content</tt>"
                        },
                        parse => 0,
                        class => 'block',
                    },
                    hr => {
                        class => 'block',
                        output => '<hr>',
                        single => 1,
                    },
                },
            }
        );

    The following list explains the above tag definitions:

    Plain text not in tags
        This defines how plain text should be rendered:

            '' => sub {
                my $e = Parse::BBCode::escape_html($_[2]);
                $e =~ s/\r?\n|\r/<br>\n/g;
                $e
            },

        In the most cases, you would want HTML escaping like shown above.
        This is the default, so you can leave it out. Only if you want to
        render BBCode into plain text or something else, you need this
        option.

    %s
            i => '<i>%s</i>'

            [i] italic <html> [/i]
            turns out as
            <i> italic &lt;html&gt; </i>

        So %s stands for the tag content. By default, it is parsed itself,
        so that you can nest tags.

    "%{parse}s"
            b   => '<b>%{parse}s</b>'

            [b] bold <html> [/b]
            turns out as
            <b> bold &lt;html&gt; </b>

        "%{parse}s" is the same as %s because 'parse' is the default.

    %a
            size => '<font size="%a">%{parse}s</font>'

            [size=7] some big text [/size]
            turns out as
            <font size="7"> some big text </font>

        So %a stands for the tag attribute. By default it will be HTML
        escaped.

    url tag, %A, "%{link}A"
            url => 'url:<a href="%{link}a">%{parse}s</a>'

        the first thing you can see is the "url:" at the beginning - this
        defines the url tag as a tag with the class 'url', and urls must not
        be nested. So this class definition is mainly there to prevent
        generating wrong HTML. if you nest url tags only the outer one will
        be parsed.

        another thing you can see is how to apply a special escape. The
        attribute defined with "%{link}a" is checked for a valid URL.
        "javascript:" will be filtered.

            [url=/foo.html]a link[/url]
            turns out as
            <a href="/foo.html">a link</a>

        Note that a tag like

            [url]http://some.link.example[/url]

        will turn out as

            <a href="">http://some.link.example</a>

        In the cases where the attribute should be the same as the content
        you should use %A instead of %a which takes the content as the
        attribute as a fallback. You probably need this in all url-like
        tags:

            url => 'url:<a href="%{link}A">%{parse}s</a>',

    "%{uri}A"
        You might want to define your own urls, e.g. for wikipedia
        references:

            wikipedia => 'url:<a href="http://wikipedia/?search=%{uri}A">%{parse}s</a>',

        "%{uri}A" will uri-encode the searched term:

            [wikipedia]Harold & Maude[/wikipedia]
            [wikipedia="Harold & Maude"]a movie[/wikipedia]
            turns out as
            <a href="http://wikipedia/?search=Harold+%26+Maude">Harold &amp; Maude</a>
            <a href="http://wikipedia/?search=Harold+%26+Maude">a movie</a>

    Don't parse tag content
        Sometimes you need to display verbatim bbcode. The simplest form
        would be a noparse tag:

            noparse => '<pre>%{html}s</pre>'

            [noparse] [some]unbalanced[/foo] [/noparse]

        With this definition the output would be

            <pre> [some]unbalanced[/foo] </pre>

        So inside a noparse tag you can write (almost) any invalid bbcode.
        The only exception is the noparse tag itself:

            [noparse] [some]unbalanced[/foo] [/noparse] [b]really bold[/b] [/noparse]

        Output:

            [some]unbalanced[/foo] <b>really bold</b> [/noparse]

        Because the noparse tag ends at the first closing tag, even if you
        have an additional opening noparse tag inside.

        The "%{html}s" defines that the content should be HTML escaped. If
        you don't want any escaping you can't say %s because the default is
        'parse'. In this case you have to write "%{noescape}".

    Block tags
            quote => 'block:<blockquote>%s</blockquote>',

        To force valid html you can add classes to tags. The default class
        is 'inline'. To declare it as a block add "'block:"" to the start of
        the string. Block tags inside of inline tags will either close the
        outer tag(s) or leave the outer tag(s) unparsed, depending on the
        option "close_open_tags".

    Define subroutine for tag
        All these definitions might not be enough if you want to define your
        own code, for example to add a syntax highlighter.

        Here's an example:

            code => {
                code => sub {
                    my ($parser, $attr, $content, $attribute_fallback, $tag, $info) = @_;
                    if ($attr eq 'perl') {
                        # use some syntax highlighter
                        $content = highlight_perl($$content);
                    }
                    else {
                        $content = Parse::BBCode::escape_html($$content);
                    }
                    "<tt>$content</tt>"
                },
                parse => 0,
                class => 'block',
            },

        So instead of a string you define a hash reference with a 'code' key
        and a sub reference. The other key is "parse" which is 0 by default.
        If it is 0 the content in the tag won't be parsed, just as in the
        noparse tag above. If it is set to 1 you will get the rendered
        content as an argument to the subroutine.

        The first argument to the subroutine is the Parse::BBCode object
        itself. The second argument is the attribute, the third is the
        already rendered tag content as a scalar reference and the fourth
        argument is the attribute fallback which is set to the content if
        the attribute is empty. The fourth argument is just for convenience.
        The fifth argument is the tag object (Parse::BBCode::Tag) itself, so
        if necessary you can get the original tag content by using:

            my $original = $tag->raw_text;

        The sixth argument is an info hash. It contains:

            my $info = {
                tags => $tags,
                stack => $stack,
                classes => $classes,
            };

        The variable $tags is a hashref which contains all tag names which
        are outside the current tag, with a count. This is convenient if you
        have to check if the current processed tag is inside a certain tag
        and you want to behave differently, like

            if ($info->{tags}->{special}) {
                # we are somewhere inside [special]...[/special]
            }

        The variable $stack contains an array ref with all outer tag names.
        So while processing the tag 'i' in

            [quote][quote][b]bold [i]italic[/i][/b][/quote][/quote]

        it contains [qw/ quote quote b i /]

        The variable $classes contains a hashref with all tag classes and
        their counts outside of the current processed tag. For example if
        you want to process URIs with URI::Find, and you are already in a
        tag with the class 'url' then you don't want to use URI::Find here.

            unless ($info->{classes}->{url}) {
                # not inside of a url class tag ([url], [wikipedia, etc.)
                # parse text for urls with URI::Find
            }

    Single-Tags
        Sometimes you might want single tags like for a horizontal line:

            hr => {
                class => 'block',
                output => '<hr>',
                single => 1,
            },

        The hr-Tag is a block tag (should not be inside inline tags), and it
        has no closing tag (option "single")

            [hr]
            Output:
            <hr>

ESCAPES
        my $p = Parse::BBCode->new({
            ...
            escapes => {
                link => sub {
                },
            },
        });

    You can define or override escapes. Default escapes are html, uri, link,
    email, htmlcolor, num. An escape functions as a validator and filter.
    For example, the 'link' escape looks if it got a valid URI (starting
    with "/" or "\w+://") and html-escapes it. It returns the empty string
    if the input is invalid.

    See "default_escapes" in Parse::BBCode::HTML for the detailed list of
    escapes.

TODO
    BBCode to Textile|Markdown
        There is a Parse::BBCode::Markdown module which is only roughly
        tested.

    API The main syntax is likely to stay, only the API for callbacks might
        change. At the moment it is not possible to add callbacks to the
        parsing process, only for the rendering phase. It is also not
        possible to declare your own attribute syntax, for example

            [quote=nickname date]

        Attributes always have to look like:

            [tag=main_attribute other=foo]...
            [tag="main_attribute" other="foo"]...

    Redirects for url tags
        In a forum you might want to prefix links and images with a redirect
        script so that the actual referrer will be hidden from the target
        url. This is extremely helpful if you are using session-ids in your
        urls. I plan to add an option for url tags which lets you define the
        redirect-script url.

REQUIREMENTS
    perl >= 5.6.1, Class::Accessor::Fast, URI::Escape

SEE ALSO
    BBCode::Parser, HTML::BBCode, HTML::BBReverse

    See "examples/compare.html" for a feature comparison of the modules and
    feel free to report mistakes.

    See "examples/bench.pl" for a benchmark of the modules.

BUGS
    Please report bugs at
    http://rt.cpan.org/NoAuth/Bugs.html?Dist=Parse-BBCode

AUTHOR
    Tina Mueller

CREDITS
    Thanks to Moritz Lenz for his suggestions about the implementation and
    the test cases.

    Viacheslav Tikhanovskii

    Sascha Kiefer

COPYRIGHT AND LICENSE
    Copyright (C) 2008 by Tina Mueller

    This library is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself, either Perl version 5.6.1 or, at
    your option, any later version of Perl 5 you may have available.

